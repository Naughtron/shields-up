reference document: https://dzone.com/articles/oauth2-implicit-grant-flow-example-using-facebook

General Overview: 

- Clients are considered "trusted" and "untrusted" 
- Pure HTML/JavaScript applications are considered untrusted OAuth2 clients becuase typically 
they do not have a way to securly store informaiton. 
-- As a result typically HTML/JavaScript applications need to init the authorization flow for each session. 

Workflow Example exchanging a friends list: 
1. The user is requesting the app to suggest more friends 
2. The app acknowledges the request and sends a url for auth 
3. The app then redirects to a consent page and presents a authorization confirmation page with a list of scopes
4. When the user agrees they are then redirected back to the app with a token 
5. The app inits a request to get the users friends list presenting the token it recieved in step 4
6. The app then recieves the friends list 

OAuth to Account takeover/Pentesting: 

reference document: https://book.hacktricks.xyz/pentesting-web/oauth-to-account-takeover
reference document: https://oauth.net/2/

Grant Types: 

Authorization Code Grant: 

Used by confidential and public clients to exchange an authorization code for 
and access token. 
Example: After a user returns to the client via a redirect url the application gets an authorization code from the 
URL and uses it to request an access token. 

PKCE Proof Key for Code Exchange: 

Extension of the Authorization Code workflow. Used to prevent attacks and to securly
perform the OAuth exchange from public clients. 
Designed to protect mobile apps. It has the ability to prevent authorization code injection makes it useful
for all OAuth clients including web apps that use a client secret. 

Client Credentials: 

This is used to by clients to obtain an access token outside of the context of a user. 
Typically this is used by clients to access resources about themselves rather then to access a users resources. 

Device Code: 

This is used by browserless or input constrained devices in a device workflow to exchange a previously obtained device
code for an access token. 
OAuth 2.0 Device Authorization Grant details: 
This workflow is seen on devices like smart TVs or media consoles. The device instructs the user to open a URL on a 
secondary device like a smartphone or computer in order to complete the authorization. 

Refresh Token: 
This grant type is used by clients to exchange a refresh token for an access token when the access token has expired. 
This allows clients to continue to have a valid access token without further interaction with the user. 

Pentesting article focus on the OAuth 2.0 authorization code grant type: 

OAuth2 element definitions

- resource owner: This is the user/entity that is granting access to a protected resource.

- resource server: This is the server that is handling authentication requests after an application obtains an access
token on behalf of the resource owner. 

- client application: This is the application that is requesting authorization from the resource owner. 

- authorization server: This is the server issuing access tokens to the client applicaiton after successfully
authenticating the resource owner and obtaining authorization.

- client_id: This is the UUID for the application. This is a public non-secret id. 

- client_secret: This is a secret known only to the applicaiton and authorization server. This is used to generate 
access tokens. 

- response_type: The response type is a value to detail which type of token is being requested. For example "code". 

- scope: This is the requested level of access the client application is requesting from the resource owner. 

- redirect_uri: This is the URL the user is redirected to after the authorization is complete. This typically must match
the redirect URL that is registered with the service. 

- state (this was the vuln in ooch): This is a param that can persist data between the user being directed to the 
authorization server and back again. It is important that this is a unique value as it serves as a CSRF protection if it 
contains a unique or random value. 
Further definition: A CSRF token is a unique / secret / unpredictable value that is generated by a server side applicaiton 
and then sent to a client. 

- grant_type: This explains what the grant type is and what token is going to be returned. 

- code: This is the authorization code recieved from the authorization server which will be included as a query string
param called "code" in the request.
The code is used with the client_id and the client_secret by the application to fetch an access_token.

- access_token: This is the token that the client application uses to make API requests on behalf of the resource owner.

- refresh_token: This allows an application to obtain a new access token without prompting the user. 

Yourtweetreader workflow example from the article: 
1. Visit https://yourtweetreader.com and click on integrate with twitter. 

2. yourtweetreader.com sends a request to twitter.com asking the user [who is the resource owner]
to authorize the yourtweetreader.com application to access the users tweets. 
Request example: 
https://twitter.com/auth
 ?response_type=code
 &client_id=yourtweetreader_clientId
 &redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
 &scope=readTweets
 &state=kasodk9d1jd992k9klaskdh123

3. The user is asked to consent

4. With consent twitter sends a request back to the redirect_uri with the code and state params.
Example: https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123

5. yourtweetreader.com then takes the code and using the applications client_id and client_secret makes a request 
from the server to retrieve an access_token on behalf of the user which allows them the set permissions consented to
Example: 
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", 
"client_secret": "yourtweetreader_clientSecret", 
"code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}

6. The workflow is now complete and yourtweetreader.com will make an API request to twitter with the users access_token
to access the tweets. 

Past Bug Bounty findings: 

Weak redirect_uri configuration

Depending on the server there are a few techniques that can be used to bypass the redirect_uri.
In the following examples assuming that the redirect_uri is https://yourtweetreader.com/callback

1. Open redirects: 
An open redirect happens when a website or applicaiton changes the URL that is accessed by a client. An Open Redirect vuln
exists when the destination of the redirect is provided by the client and it is not then filtered or validated. 
example: https://radsite.com/redirect.php?url=http://giantbomb.com

In the context of OAuth2: 
https://yourtweetreader.com/callback?redirectUrl=https://evil.com

2. Path Traversal: 
In this instance you are trying to access files or directories that are outside of a root folder. By passing variables 
that reference files with ../
example: http://example.com/?file=../../../../etc/passwd

In the context of OAuth2: 
https://yourtweetreader.com/callback/../redirect?url=https://evil.com

3. Weak regexes: 
Permitting things like https://yourtweetreader.com.evil.com

4. HTML Injection: 
Example https://yourtweetreader.com/callback/home/attackerimg.jpg

Other parmas that could be vulnrible to Open Redirect

client_uri: This is the home page of the client applicaiton

policy_uri: This is the url that the relying party client application provides so that the end user can read about 
how the profile data will be used. 

tos_uri: This is the url that the relying party client provides so that the end user can read about the terms of service. 

initiate_login_uri: This is using the https scheme that a third parcy can use to init a login by the relying party. 

All of the above params are optional with OAuth and OpenID and are not always supported. It is worth ID'ing
the params that are supported on the server. 

If you can ID that the target is an OpenID server the discovery endpoing at .well-known/openid-configuration can 
contain things like: registration_endpoint, request_uri_parameter_supported, and require_request_uri_registration. 
These values can help with finding the registration endpoint. 

2. SSRF against the /register engpoint
SSRF Attack: When an attacker supplys or modifies a URL which the code running on the server will read and submit
data to. Attackers can also use this to read configuration data. 

In this case there is an OAuth /register endpoint that accecpts POSTs. 

Example Request: 
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
 "application_type": "web",
 "redirect_uris": ["https://client.example.org/callback"],
 "client_name": "My Example",
 "logo_uri": "https://client.example.org/logo.png",
 "subject_type": "pairwise",
 "sector_identifier_uri": "https://example.org/rdrct_uris.json",
 "token_endpoint_auth_method": "client_secret_basic",
 "jwks_uri": "https://client.example.org/public_keys.jwks",
 "contacts": ["ve7jtb@example.org"],
 "request_uris": ["https://client.example.org/rf.txt"]
}

The article notes that most servers they tested do not resolve the URLs immediately when the request is recieved. 
The params are saved and used later during an authorization workflow. 

The following params can be used as targets: 

logo_uri: This is the URL that references a logo on the client application. After registering a client with the POST
make a request to /authorize using a valid client_id. After the login the server will ask the user to approve the request.
At this point is may display the logo submitted via logo_uri. If the server fetches the image by itself the SSRF should be
triggered. 
If the logo comes back with <img> tag this will not lead to SSRF but could be XXS if the url is not escaped. 

3. Improper handling of state parameter [vuln used in ooch]

This is a common misconfiguration. The state param is either omitted or used incorrectly. 
If the state param does not exist or set to a static value that never changes the OAuth workflow 
will be very likely vulnrible to a CSRF attack. 
NOTE: Even if the state param is present there may not be validation on it so it is worth testing. 

To run this exploit: 
1. Go through the authorization workflow using a valid account 
2. Right after authorizing there will be a request like this https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
3. The code is a one time use so you can then send it to another logged in user and it will add the account to that user. 
4. Because OAuth is most commonly used for sign-in you could potentially take over another users account. 

The article also mentions that the state param has been used as a redirect value from time to time. 
An application will use the redirect_uri for the initial redirect but then use the state param as a second and that could 
contain the code in the query params or refrence header. 
The article has also seen instances where this has been used in Slack, Stripe and PayPal integrations. 
